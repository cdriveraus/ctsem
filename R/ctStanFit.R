#' ctStanFit
#'
#' Fits a ctsem model specified via \code{\link{ctModel}} with type either 'stanct' or 'standt', using Bayseian inference software
#' Stan. 
#' 
#' @param datalong long format data containing columns for subject id, manifest variables, 
#' any time dependent (i.e. varying within subject) predictors, 
#' and any time independent (not varying within subject) predictors.
#' @param ctstanmodelobj model object as generated by \code{\link{ctModel}} with type='stanct' or 'standt'.
#' @param kalman logical indicating whether or not to integrate over latent states using a Kalman filter. 
#' Generally recommended to set TRUE.
#' @param densehyper logical indicating whether to estimate a prior for correlations between parameters, or fix it to 0.
#' Samples much faster if set to FALSE, but setting TRUE may improve estimation of priors for subject level parameters.
#' @param fit If TRUE, fit specified model using Stan, if FALSE, return stan model object without fitting.
#' @param noncentered if FALSE, sample subject level parameters directly, if TRUE, sample subject level parameters as
#' deviations from the estimated population mean. TRUE seems to result in somewhat more effective sampling, 
#' based on limited testing.
#' @param optimize if TRUE, use Stan's optimizer for maximum a posteriori estimates. Not recommended unless
#' no parameters vary across subjects.
#' @param vb if TRUE, use Stan's variational approximation. Presently experimental and not recommended.
#' @param iter number of iterations, half of which will be devoted to warmup.
#' @param chains number of chains to sample.
#' @export
ctStanFit<-function(datalong, ctstanmodelobj, kalman=TRUE, densehyper=FALSE,
 fit=TRUE, plot=FALSE, noncentered=TRUE,
  optimize=FALSE, vb=FALSE, chains=3,...){
  
  nonlinear=FALSE

  stanplot<-function(chains,seed){
    wd<-  paste0("setwd('",getwd(),"')")
    writeLines(text=paste0(wd,'
      seed<-',seed,';
      chains<-',chains,';
      
      notyet<-TRUE
      while(notyet==TRUE){
      Sys.sleep(10);
      samps<-try(read.csv(file=paste0(seed,"samples.csv",1),comment.char="#"))
      if(class(samps) != "try-error") notyet<-FALSE
      }
      varnames<-colnames(samps);
      require(shiny); 
      shiny::runApp(appDir=list(server=function(input, output,session) {
      
           output$chainPlot <- renderPlot({
      parameter<-input$parameter
      begin<-input$begin
      colimport<-rep("NULL",length(varnames))
      colimport[which(varnames %in% parameter)]<-NA
      begin<-input$begin
      samps<-list()
      for(chaini in 1:chains) {
      samps[[chaini]]<-read.csv(file=paste0(seed,"samples.csv",chaini),comment.char="#",colClasses = colimport)
      }
      
      mini<-min(unlist(lapply(1:chains,function(chaini) samps[[chaini]][-1:-begin,parameter])),na.rm=T)
      maxi<-max(unlist(lapply(1:chains,function(chaini) samps[[chaini]][-1:-begin,parameter])),na.rm=T)
      lengthi<-max(unlist(lapply(1:chains,function(chaini) length(samps[[chaini]][-1:-begin,parameter]))),na.rm=T)

      plot(begin:lengthi,
      c(samps[[1]][-1:-begin,parameter],rep(NA,lengthi-length(samps[[1]][-1:-begin,parameter]))),
      type="l",xlab="",ylab="",main=parameter,
      log=ifelse(parameter %in% c("stepsize__"),"y",""),
      xlim=c(begin,lengthi),
      ylim=c(mini,maxi)
      )

      if(chains > 1) for(chaini in 2:chains){
      points(begin:lengthi,c(samps[[chaini]][-1:-begin,parameter],rep(NA,lengthi-length(samps[[chaini]][-1:-begin,parameter]))),type="l",xlab="",ylab="",main=parameter,col=chaini)
      }
grid()
      
      })
      },ui=fluidPage(
      # Application title
      titlePanel("Hello Shiny!"),
      sidebarLayout(
      # Sidebar with a slider input for number of observations
      sidebarPanel(
      sliderInput("begin", "Start of range:", min = 1,max=length(samps[,2]),value = 1,step=1), 
      selectInput("parameter", "Choose a parameter:", choices = varnames),
      actionButton("refresh", "Refresh sample data")
      ),
      
      # Show a plot of the generated distribution
      mainPanel(
      plotOutput("chainPlot")
      )
      ))),
      launch.browser=TRUE)
      quit(save="no")'),con='stanplottemp.R')
    system(paste0("Rscript.exe --slave --no-restore -e source('",getwd(),"/stanplottemp.R')"),wait=F)
    
  }
  
  #read in ctmodel values
  ctspec<-ctstanmodelobj$parameters
  n.latent<-ctstanmodelobj$n.latent
  n.manifest<-ctstanmodelobj$n.manifest
  n.TDpred<-ctstanmodelobj$n.TDpred
  n.TIpred<-ctstanmodelobj$n.TIpred
  
  manifestNames<-ctstanmodelobj$manifestNames
  latentNames<-ctstanmodelobj$latentNames
  TDpredNames<-ctstanmodelobj$TDpredNames
  TIpredNames<-ctstanmodelobj$TIpredNames
  id<-ctstanmodelobj$subjectIDname
  continuoustime<-ctstanmodelobj$continuoustime
  indvarying<-ctspec$indvarying
  nindvarying<-sum(indvarying)
  nparams<-sum(is.na(ctspec$value))
  
  
  
  #data checks
  if(any(is.na(as.numeric(datalong[,id])))) stop('id column may not contain NA\'s or character strings!')
  
  
  T0check<-1
  for(i in 2:nrow(datalong)){
    T0check<-c(T0check, ifelse(datalong[,'id'][i] != datalong[,'id'][i-1], 1, 0))
  }
  
  if(any(is.na(datalong[,'dT']))) stop('Missing time intervals!')
  if(n.TDpred > 0) {
    datalong[,TDpredNames][is.na(datalong[,TDpredNames])] <-0 ## temporary fix for missingness
    if(any(is.na(datalong[,TDpredNames]))) stop('Missingness in TDpreds!')
  }
  if(n.TIpred > 0) {
    if(n.TIpred > 0) tipreds <- datalong[match(unique(datalong[,id]),datalong[,id]),TIpredNames,drop=FALSE]
    if(any(is.na(tipreds))) stop('Missingness in TIpreds!')
}
  
  datalong[is.na(datalong)]<-99999 #missing data
  
  intervalChange<-cbind(c(1,as.numeric((datalong[,'dT'][2:nrow(datalong)]-datalong[,'dT'][1:(nrow(datalong)-1)])!=0)))
  colnames(intervalChange)<-'intervalChange'
  datalong<-cbind(datalong,intervalChange)
  
  if(n.TDpred > 0) tdpreds <- datalong[,TDpredNames,drop=FALSE]
  
  nsubjects <- length(unique(datalong[, 'id'])) 
  
  if(kalman==FALSE) {
    message('ATTENTION: T0VAR matrix is ignored when kalman=FALSE \n')
    ctspec<-ctspec[-which(ctspec$matrix %in% 'T0VAR'),]
    if(any(!is.na(ctspec[ctspec$matrix %in% 'T0MEANS','value']))) message('ATTENTION: Some T0MEANS are fixed - may be problematic when kalman=FALSE \n')
  }
  
    stanmodelobj <- paste0('
    functions{
    
    matrix fillcholcordiag(matrix mat){
    matrix[rows(mat),cols(mat)] out;
    real tempsum;
    out[1,1]<-1;
    if(rows(mat) > 1){
    for(rowi in 2:rows(out)){
    tempsum<-0;
    for(coli in 1:(rowi-1)){
    out[rowi,coli]<-mat[rowi,coli];
    out[coli,rowi] <- 0;
    tempsum <- tempsum + mat[rowi,coli]^2;
    }
    out[rowi,rowi]<-sqrt(fabs(1-tempsum));
    }
    }
    return out;
    }
    
    
    
    matrix varmatrixtransform(matrix mat){
    int ndim;
    matrix[rows(mat),cols(mat)] mscale;
    matrix[rows(mat),cols(mat)] mcholcor;
    matrix[rows(mat),cols(mat)] mchol;
    matrix[rows(mat),cols(mat)] mtx;
    ndim <- cols(mat);
    for(coli in 1:ndim){
    for(rowi in 1:ndim){
    
    if(rowi==coli) {
    mscale[rowi,coli] <-  mat[rowi,coli];
    }
    
    if(rowi > coli){
    mscale[rowi,coli] <-0;
    mscale[coli,rowi] <-0;
    mcholcor[rowi,coli] <-  mat[rowi,coli]; 
    }
    }}
    mcholcor <- fillcholcordiag(mcholcor);
    mchol <- mscale * mcholcor;
    mtx<-multiply_lower_tri_self_transpose(mchol) ;
    return mtx;
    }
    

    matrix expmp(matrix A, matrix padeC, vector padeCbig){
    int n;
    real nA;
    real colsum;
    int l;
    matrix[4,10] C;
    vector[4] t;
    matrix[rows(A),rows(A)] I;
    matrix[rows(A),rows(A)] P;
    matrix[rows(A),rows(A)] U;
    matrix[rows(A),rows(A)] V;
    matrix[rows(A),rows(A)] X;
    
    vector[14] Cbig;
    real s;
    real si;
    matrix[rows(A),rows(A)] B;
    matrix[rows(A),rows(A)] B2;
    matrix[rows(A),rows(A)] B4;
    matrix[rows(A),rows(A)] B6;
    matrix[rows(A),rows(A)] A2;
    
    si <- 0;
    C <- padeC;
    Cbig <- padeCbig;
    
    n <-rows(A);
    if(n != cols(A)) print("expmp: Matrix not square!")
    
    if (n <= 1) X <- exp(A);
    else{
    
    // nA <- Matrix::norm(A, "1")
    nA <- 0;
    for(coli in 1:n){
    colsum<-0;
    for(rowi in 1:n){
    colsum<-colsum+fabs(A[rowi,coli]);
    }
    if(colsum > nA) nA <- colsum;
    }
    
    I <- diag_matrix(rep_vector(1,n));
    if (nA <= 2.1) {
    t[1] <- 0.015; t[2]<- 0.25; t[3]<- 0.95; t[4]<- 2.1;
    
    //l <- which.max(nA <= t)
    for(ti in 1:4){
    if(l==0){
    if(nA <= t[ti]) l <- ti;
    }
    }
    
    A2 <- A * A;
    P <- I;
    U <- C[l, 2] * I;
    V <- C[l, 1] * I;
    for (k in 1:l) {
    P <- P * A2;
    U <- U + C[l, (2 * k) + 2] * P;
    V <- V + C[l, (2 * k) + 1] * P;
    }
    U <- A * U;
    X <- inverse(V - U) * (V + U);
    }
    
    else {
    s <- log2(nA/5.4);
    B <- A;
    if (s > 0) {
    s <- ceil(s);
    B <- B/(2^s);
    }
    
    B2 <- B * B;
    B4 <- B2 * B2;
    B6 <- B2*B4;
    U <- B*(B6*(Cbig[14] * B6 + Cbig[12] * B4 + Cbig[10] * B2) + Cbig[8] * B6 + Cbig[6] * B4 + Cbig[4] * B2 + Cbig[2] * I);
    V <- B6*(Cbig[13] * B6 + Cbig[11] * B4 + Cbig[9] * B2) + Cbig[7] * B6 + Cbig[5] * B4 + Cbig[3] * B2 + Cbig[1] * I;
    X <- inverse(V - U) * (V + U);
    
    if (s > 0) {
    while (si < s){ 
    si <- si + 1;
    X <- X * X;
    }
    }
    }
    
    }
    return X;
    }
    
    
    
    
    
    matrix kron_prod(matrix mata, matrix matb){
    int m;
    int p;
    int n;
    int q;
    matrix[rows(mata)*rows(matb),cols(mata)*cols(matb)] C;
    m<-rows(mata);
    p<-rows(matb);
    n<-cols(mata);
    q<-cols(matb);
    for (i in 1:m){
    for (j in 1:n){
    for (k in 1:p){
    for (l in 1:q){
    C[p*(i-1)+k,q*(j-1)+l] <- mata[i,j]*matb[k,l];
    }
    }
    }
    }
    return C;
    }
    
    matrix makesym(matrix mat){
    matrix[rows(mat),cols(mat)] out;
    out<-mat;
    for(rowi in 1:rows(mat)){
    for(coli in 1:cols(mat)){
    if(coli > rowi) out[rowi,coli]<-out[coli,rowi];
    }
    }
    return out;
    }

}
data {
  matrix[4,10] padeC; // for matrix exponential
  vector[14] padeCbig;
  int<lower=0> ndatapoints;
  int<lower=1> nmanifest;
  int<lower=1> nlatent;
  int<lower=1> nsubjects;
  
  ',if(n.TIpred > 0) paste0('int<lower=0> ntipred; // number of time independent covariates
    matrix[nsubjects,ntipred] tipreds; '),'
  
  vector[nmanifest] Y[ndatapoints];
  int<lower=0> ntdpred; // number of time dependent covariates
  
  ',if(n.TDpred > 0) paste0('vector[ntdpred] tdpreds[ndatapoints];'),'
  
  vector[ndatapoints] dT; // time intervals
  int intervalChange[ndatapoints]; //logical indicating if interval changes
  int subject[ndatapoints];
  int<lower=0> nparams;
  int T0check[ndatapoints]; // logical indicating which rows are the first for each subject
  int continuoustime; // logical indicating whether to incorporate timing information
  int nindvarying; // number of subject level parameters that are varying across subjects
  ',if(nindvarying>0) paste0('int indvaryingindex',if(nindvarying>1) '[nindvarying]',';'),'
  
  int<lower = 0, upper = nmanifest> nobs_y[ndatapoints];  // number of observed variables per observation
  int<lower = 0, upper = nmanifest> whichobs_y[ndatapoints, nmanifest]; // index of which variables are observed per observation
  }
  
  transformed data{
  matrix[nlatent,nlatent] IIlatent;
  IIlatent <- diag_matrix(rep_vector(1,nlatent));
}
    
parameters {

  vector[nparams] hypermeans; // subject level parameter means \n','
  
  ',if(any(indvarying)) {
  'vector[nindvarying] indparams[nsubjects]; //subject level parameters
  vector<lower=0>[nindvarying] hypersd; // population sd of any varying subject level parameters
  '},'

',if(any(indvarying) & densehyper==TRUE) 'cholesky_factor_corr[nindvarying] hypercholcorr; // cholesky correlation of varying subject parameters\n','
  
  ',if(n.TIpred > 0) paste0('vector[',sum(unlist(ctspec[,paste0(TIpredNames,'_effect')])),'] tipredeffectparams; // effects of time independent covariates\n'),'
      
  ',if(kalman==FALSE) 'vector[nlatent] eta[ndatapoints-nsubjects]; // latent states excluding initial T0 ones\n','

}
    
transformed parameters{

',if(any(nindvarying)) '
matrix[nindvarying,nindvarying] paramchol; //cholesky of population covariance of varying subject parameters
matrix[nindvarying,nindvarying] invparamchol; //just storing the inverse
vector[nindvarying*nsubjects] indparamstrans; // transformation of subject level parameters to standard normal dist \n','

  matrix[nlatent,nlatent] DIFFUSION[nsubjects]; //additive latent process variance
  matrix[nlatent,nlatent] T0VAR[nsubjects]; //initial latent process variance
  matrix[nlatent,nlatent] DRIFT[nsubjects]; //dynamic relationships of processes
  ',if(continuoustime) 'matrix[nlatent,nlatent] invDRIFT[nsubjects]; \n','
  matrix[nmanifest,nmanifest] MANIFESTVAR[nsubjects]; // manifest error variance
  vector[nmanifest] MANIFESTMEANS[nsubjects];
  vector[nlatent] T0MEANS[nsubjects]; // initial (T0) latent states
  matrix[nmanifest,nlatent] LAMBDA[nsubjects]; // loading matrix
  vector[nlatent] CINT[nsubjects]; // latent process intercept
  matrix[nlatent,nlatent] asymDIFFUSION[nsubjects]; //latent process variance as time interval goes to inf


',if(n.TDpred > 0) paste0('matrix[nlatent,ntdpred] TDPREDEFFECT[nsubjects]; // effect of time dependent predictors'),'
',if(n.TIpred > 0) paste0('matrix[',nindvarying,',',n.TIpred,'] tipredeffect; //design matrix of individual time independent predictor effects'),'

',if(n.TIpred > 0) paste0(unlist(lapply(1,function(x){ ## collects all the time independent predictors effects into the design matrix
      count<-0
      tirow<-0
      out<-c()
      for(rowi in 1:nrow(ctspec[,])){
        if(is.na(ctspec$value[rowi]) & ctspec$indvarying[rowi]) {
          tirow<-tirow+1
          for(predi in 1:n.TIpred){
            if(ctspec[rowi, paste0(TIpredNames[predi],'_effect')] == FALSE) out<-c(out, ' tipredeffect[',tirow,', ', predi,'] <- 0; \n')
            if(ctspec[rowi, paste0(TIpredNames[predi],'_effect')] == TRUE) {
              count<-count+1
              out<-c(out, ' tipredeffect[',tirow,', ', predi,'] <- tipredeffectparams[',count,']; \n ')
            }
          }
        }}
      return(out)
    })),collapse=''),'


',if(any(ctspec$indvarying)) paste0(
if(densehyper==TRUE) 'paramchol<- diag_pre_multiply(hypersd,hypercholcorr); ',
  if(densehyper==FALSE) 'paramchol<-diag_matrix(hypersd);',
'invparamchol <- inverse(paramchol);\n'),'
    
{
',if(continuoustime) 'matrix[nlatent*nlatent,nlatent*nlatent] DRIFTHATCH;  \n','
vector[nlatent*nlatent] asymDIFFUSIONvec;

',if(any(ctspec$indvarying)) paste0('
  for(subjecti in 1:nsubjects){ // transform subject parameters to standard normal dist
  indparamstrans[(1+(subjecti-1)*nindvarying):(subjecti*nindvarying)]<-invparamchol * (indparams[subjecti]',
  if(n.TIpred>0) '-tipredeffect * tipreds[subjecti]\' ',
  if(noncentered==FALSE) '-hypermeans[indvaryingindex]',
  ');
  }
  '),'


for(subjecti in 1:nsubjects){ // create subject specific parameter matrices from fixed and transformed free effects 
',paste0(unlist(lapply(1:nrow(ctspec),function(rowi) {
  
  x<-paste0(
  ctspec[rowi,'matrix'], '[subjecti][', ctspec[rowi,'row'], 
  if(ctspec[rowi,'matrix'] %in% c('LAMBDA','DRIFT','DIFFUSION',
    'MANIFESTVAR', 'TDPREDEFFECT', 'T0VAR')) paste0(' , ', ctspec[rowi,'col']),
  ']') 

paste0(x, '<- ', 
  if(is.na(ctspec[rowi,'value']) & (noncentered | !ctspec$indvarying[rowi])) paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),']'),
  if(ctspec[rowi,'indvarying'] & noncentered) ' + ',
  if(ctspec[rowi,'indvarying']) paste0('indparams[subjecti][',which(ctspec[ctspec$indvarying,'param']==ctspec[rowi,'param']),']'),
  if(9999==8888 & n.TIpred > 0 & is.na(ctspec[rowi,'value'])) paste0(' + tipredeffect[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),',1:ntipred] * tipreds[subjecti,1:ntipred]\' '),
  if(!is.na(ctspec[rowi,'value'])) ctspec[rowi,'value'],
  
  '; \n',
  
  if(!is.na(ctspec$transform[rowi]) & is.na(ctspec$value[rowi])) paste0(
    x, ' <- ', gsub('param',x,ctspec$transform[rowi]),'; \n'),
  
    collapse='')
})),collapse=''),
'}


for(individual in 1:nsubjects){ // perform any whole matrix transformations 
    
  MANIFESTVAR[individual] <- varmatrixtransform(MANIFESTVAR[individual]);
  DIFFUSION[individual] <- varmatrixtransform(DIFFUSION[individual]);
  T0VAR[individual] <- varmatrixtransform(T0VAR[individual]);
  
  ',if(continuoustime==TRUE) paste0('
    invDRIFT[individual] <- inverse(DRIFT[individual]);
    DRIFTHATCH <- kron_prod(DRIFT[individual],diag_matrix(rep_vector(1, nlatent))) + kron_prod(diag_matrix(rep_vector(1, nlatent)),DRIFT[individual]);
    
    asymDIFFUSIONvec <- -inverse(DRIFTHATCH) * to_vector(DIFFUSION[individual]);
    for(drowi in 1:nlatent) {
    for(dcoli in 1:nlatent){
    asymDIFFUSION[individual][drowi,dcoli] <- asymDIFFUSIONvec[drowi+(dcoli-1)*nlatent];
    if(drowi > dcoli) asymDIFFUSION[individual][drowi,dcoli] <- asymDIFFUSION[individual][dcoli,drowi]; //symmetry enforcement
    }}
    '),
  if(continuoustime==FALSE) paste0('
    asymDIFFUSIONvec <- (diag_matrix(rep_vector(1, nlatent*nlatent)) - kron_prod(DRIFT[individual],DRIFT[individual])) * to_vector(DIFFUSION[individual]);
    for(drowi in 1:nlatent) {
    for(dcoli in 1:nlatent){
    asymDIFFUSION[individual][drowi,dcoli] <- asymDIFFUSIONvec[drowi+(dcoli-1)*nlatent];
    if(drowi > dcoli) asymDIFFUSION[individual][drowi,dcoli] <- asymDIFFUSION[individual][dcoli,drowi]; //symmetry enforcement
    }}
    '),'
}

}    
}
    
    
model{
  matrix[nlatent,nlatent] discreteDIFFUSION; //discrete time parameter matrices
  vector[nlatent] discreteCINT;
  matrix[nlatent,nlatent] discreteDRIFT;

',if(kalman==TRUE) paste0('
  vector[nlatent] etaprior[ndatapoints]; //prior for latent states
  matrix[nlatent, nlatent] etapriorcov[ndatapoints]; //prior for covariance of latent states
  vector[nlatent] etapost[ndatapoints + 1]; //posterior for latent states
  matrix[nlatent, nlatent] etapostcov[ndatapoints + 1]; //posterior for covariance of latent states
  vector[sum(nobs_y)] errtrans; // collection of prediction errors transformed to standard normal
  int obscount; // counter summing over number of non missing observations in each row
'),'
  
hypermeans~normal(0,1);

',if(n.TIpred > 0) paste0('tipredeffectparams ~ normal(0,.1); \n '),' 

',if(any(ctspec$indvarying)) paste0('
  hypersd ~ normal(0,.5);
  indparamstrans ~ normal(0,1);
  increment_log_prob(sum(log(diagonal(invparamchol)))*nsubjects); //adjust loglik for density warping transform of prediction errors
'),' 

    
    
    
    
    
',if(kalman==FALSE) paste0('
{
vector[(ndatapoints-nsubjects)*nlatent] etatrans; //collection of latent states transformed to standard normal
vector[ndatapoints*nmanifest] Ytrans; //collection of observations transformed to standard normal
matrix[nmanifest,nmanifest] invMANIFESTVARchol; //inverse of cholesky of manifest variance
matrix[nlatent,nlatent]invdiscreteDIFFUSIONchol; //inverse of cholesky of discrete time latent variance
int subjecti;

for(rowi in 1:ndatapoints){
  subjecti <- subject[rowi];
  
  if(T0check[rowi]==1) { // if first row for this subjecti
    invMANIFESTVARchol <- inverse(cholesky_decompose(MANIFESTVAR[subjecti]));
    ',if(continuoustime==FALSE) paste0('
      discreteDRIFT<- DRIFT[subjecti];
      discreteCINT<- CINT[subjecti];
      invdiscreteDIFFUSIONchol <- cholesky_decompose(inverse_spd(DIFFUSION[subjecti]));
    '),'
  }
  
  ',if(continuoustime==TRUE) 'if(T0check[rowi]==0 && intervalChange[rowi]==1){ // if the time interval changes and its not the first row
    discreteDRIFT<- expmp(DRIFT[subjecti] * dT[rowi], padeC, padeCbig);
    discreteCINT<- invDRIFT[subjecti] * (discreteDRIFT - IIlatent) * CINT[subjecti];
    discreteDIFFUSION <- asymDIFFUSION[subjecti] - quad_form(asymDIFFUSION[subjecti], discreteDRIFT\');
    invdiscreteDIFFUSIONchol <- inverse(cholesky_decompose(discreteDIFFUSION));
  }','
  
  if(T0check[rowi] ==0){ //transform latent states to standard normal and increment loglik to acccount for density warp
        
    if(T0check[rowi-1] ==1)  etatrans[((rowi-1-subjecti)*nlatent+1) : ((rowi-subjecti)*nlatent)] <- 
            invdiscreteDIFFUSIONchol * (eta[rowi-subjecti] - discreteDRIFT * T0MEANS[subjecti] - discreteCINT',
    if(n.TDpred > 0) '- TDPREDEFFECT[subjecti] * tdpreds[rowi]',
    '); \n','

    if(T0check[rowi-1] ==0)  etatrans[((rowi-1-subjecti)*nlatent+1) : ((rowi-subjecti)*nlatent)] <- 
        invdiscreteDIFFUSIONchol * (eta[rowi-subjecti] - discreteDRIFT * eta[rowi-1-subjecti] + discreteCINT',
     if(n.TDpred > 0) '- TDPREDEFFECT[subjecti] * tdpreds[rowi]',
     '); \n','

    increment_log_prob(sum(log(diagonal(invdiscreteDIFFUSIONchol))));
  }

  if(T0check[rowi] ==0) Ytrans[((rowi-1)*nmanifest+1):(rowi*nmanifest)] <- 
    invMANIFESTVARchol * (Y[rowi] - LAMBDA[subjecti] * ',
  if(nonlinear==FALSE) 'eta[rowi-subjecti]', 
  if(nonlinear==TRUE) '(1 ./ (1+exp(eta[rowi-subjecti])))',
  ' - MANIFESTMEANS[subjecti]);

  if(T0check[rowi] ==1) Ytrans[((rowi-1)*nmanifest+1):(rowi*nmanifest)] <- 
    invMANIFESTVARchol * (Y[rowi] - LAMBDA[subjecti] * ',
  if(nonlinear==FALSE) 'T0MEANS[subjecti]', 
  if(nonlinear==TRUE) '(1 ./ (1+exp(T0MEANS[subjecti])))',
  ' - MANIFESTMEANS[subjecti]);

  increment_log_prob(sum(log(diagonal(invMANIFESTVARchol))));
}
etatrans~normal(0,1);
Ytrans~normal(0,1);
}
   
'),'
    
    
',if(kalman==TRUE) paste0('      
      
  obscount<-1;
{
int subjecti;
int nobsi;

for(rowi in 1:ndatapoints){
  subjecti<-subject[rowi];
  nobsi <- nobs_y[rowi];
  
  if(rowi!=1) obscount<-obscount+nobs_y[rowi-1]; // number of non missing observations until now
  
  if(T0check[rowi] == 1) { // calculate initial matrices if this is first row for subjecti
  
  ',if(continuoustime==FALSE) paste0('
    discreteDRIFT<- DRIFT[subjecti]; // discrete time models dont need to be udpdated each row
    discreteCINT<- CINT[subjecti];
    discreteDIFFUSION <- DIFFUSION[subjecti];'),'
  
  etaprior[rowi] <- T0MEANS[subjecti]; //prior for latent state of this row
  ',if(n.TDpred > 0) paste0('etaprior[rowi] <-TDPREDEFFECT[subjecti] * tdpreds[rowi] + etaprior[rowi];'),'
  etapriorcov[rowi] <-  T0VAR[subjecti];
  }
  
  if(T0check[rowi]==0){
  ',if(continuoustime==TRUE) paste0('
    if(intervalChange[rowi]==1){ // if the time interval changes we need to calculate new discrete time matrices
    discreteDRIFT<- expmp(DRIFT[subjecti] * dT[rowi], padeC, padeCbig);
    discreteCINT<- invDRIFT[subjecti] * (discreteDRIFT - IIlatent) * CINT[subjecti];
    discreteDIFFUSION <- asymDIFFUSION[subjecti] - quad_form_sym(asymDIFFUSION[subjecti], discreteDRIFT\');
    }'),'
  etaprior[rowi] <- discreteCINT  + discreteDRIFT * etapost[rowi]; //prior for latent state of this row
  ',if(n.TDpred > 0) paste0('etaprior[rowi] <-TDPREDEFFECT[subjecti] * tdpreds[rowi-1] + etaprior[rowi];'),'
  etapriorcov[rowi] <-  quad_form(etapostcov[rowi], discreteDRIFT\')  + discreteDIFFUSION;
    }

  if (nobsi == 0) {      // if all observations missing
  etapost[rowi + 1] <- etaprior[rowi];
  etapostcov[rowi + 1] <- etapriorcov[rowi];

  } else { // if some observations create right size matrices for missingness and calculate...
  vector[nobsi] Y_filt;
  matrix[nobsi, nlatent] LAMBDA_filt;
  vector[nobsi] MANIFESTMEANS_filt;
  matrix[nobsi, nobsi] MANIFESTVAR_filt;
  vector[nobsi] Ypred_filt;      
  matrix[nobsi, nobsi] Ypredcov_filt;
  vector[nobsi] err;
  matrix[nlatent, nobsi] K_filt; // kalman gain
  matrix[nobsi, nobsi] invYpredcov_filt;
  matrix[nobsi, nobsi] invYpredcov_filt_chol;
  
for(obsi in 1:nobsi){ // for non missing observations in this row
  Y_filt[obsi] <- Y[rowi][whichobs_y[rowi][obsi]]; // filter the data
  MANIFESTMEANS_filt[obsi] <- MANIFESTMEANS[subjecti][whichobs_y[rowi][obsi]]; // and manifest means
  LAMBDA_filt[obsi] <- LAMBDA[subjecti][whichobs_y[rowi][obsi]]; // and loading matrix
for(obsj in 1:nobsi){
  MANIFESTVAR_filt[obsi,obsj] <- MANIFESTVAR[subjecti][whichobs_y[rowi][obsi], whichobs_y[rowi][obsj]]; // and manifest variance
}
}

  Ypred_filt <- MANIFESTMEANS_filt + LAMBDA_filt * etaprior[rowi]; // predictions of y given prior
  Ypredcov_filt <- quad_form(etapriorcov[rowi], LAMBDA_filt\') + MANIFESTVAR_filt;
  
  err <- Y_filt - Ypred_filt; // prediction error
  
  invYpredcov_filt <- inverse_spd(Ypredcov_filt) ;
  invYpredcov_filt_chol<-cholesky_decompose(invYpredcov_filt); 

  K_filt <- etapriorcov[rowi] * LAMBDA_filt\' * invYpredcov_filt; 

  etapost[rowi + 1] <- etaprior[rowi] + K_filt * err;

  etapostcov[rowi + 1] <- (IIlatent - K_filt * LAMBDA_filt) * etapriorcov[rowi];

  errtrans[obscount:(obscount+nobsi-1)]<-invYpredcov_filt_chol*err; //transform pred errors to standard normal dist and collect
  increment_log_prob(sum(log(diagonal(invYpredcov_filt_chol)))); //account for transformation of scale in loglik
  }
    }
  errtrans~normal(0,1); 
}
  '),'

    
    
    
    
    
    
    
    
    ', if(optimize==TRUE && n.TIpred > 0) paste0('print("tipredeffect ",tipredeffect);'),'
    ', if(optimize==TRUE | vb==TRUE) paste0('
      //print("hypersd",hypersd);
      //print("hypercholcorr",hypercholcorr);
      print("DRIFT ", DRIFT[1]);
      //print("DIFFUSION ", DIFFUSION[1]);
      //print("T0VAR ", T0VAR[1]);
      //print("MANIFESTVAR ", MANIFESTVAR[1]);
      //print("T0MEANS[1] ", T0MEANS[1]);
      //print("CINT ", CINT[1]);
      print("MANIFESTMEANS ", MANIFESTMEANS[1]);
      print("lp =",get_lp());
      '),'\n
    
      }
generated quantities{

',if(nindvarying > 1) 'matrix[nindvarying,nindvarying] output_indparams_cov; \n','

',paste0('real output_hmean_',ctspec$param[is.na(ctspec$value)],'; \n',collapse=''),'

',paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
  if(ctspec$indvarying[rowi]) paste0('real output_hsd_',ctspec$param[rowi],'; \n')
})),collapse=''),'

',if(n.TIpred > 0) paste0(unlist(lapply(1:n.TIpred,function(tip){
  paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
    if(ctspec$indvarying[rowi] & ctspec[,paste0(TIpredNames[tip],'_effect')][rowi]) paste0('real output_tip_',
      TIpredNames[tip], '_on_', ctspec$param[rowi],'; \n'
    )
  })),collapse='')
})),collapse=''),'

',if(nindvarying > 1) paste0('
{
vector[nindvarying] output_indmeans;
matrix[nsubjects,nindvarying] output_indparams_centered;
matrix[nsubjects,nindvarying] output_indparams;
for(subjecti in 1:nsubjects){
  ',
  paste0(unlist(lapply(1:nindvarying,function(indvi){
  paste0('output_indparams[subjecti,',indvi,'] <- ',
    gsub('param', paste0('indparams[subjecti,',indvi,']'),ctspec$transform[ctspec$indvarying][indvi]),'; \n')})),collapse=''),'
}
 for (parami in 1:nindvarying){
      output_indmeans[parami] <- mean(row(output_indparams, parami));
      for (subjecti in 1:nsubjects)  {
        output_indparams_centered[subjecti,parami] <- output_indparams[subjecti,parami] - output_indmeans[parami];
      }
    }
    output_indparams_cov <- output_indparams_centered\' * output_indparams_centered / (nsubjects-1);
output_indparams_cov <- .5*(output_indparams_cov + output_indparams_cov\'); 
}'),'

',paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
  if(is.na(ctspec$value[rowi])) paste0('output_hmean_',ctspec$param[rowi],' <- ',
      gsub('param',
       paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),']'),
ctspec$transform[rowi]),'; \n')
    })),collapse=''),'


',paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
  if(ctspec$indvarying[rowi]) paste0('output_hsd_',ctspec$param[rowi],' <- ',
    'hypersd[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),']; \n',
    if(!is.na(ctspec$transform[rowi])) paste0(
      'output_hsd_',ctspec$param[rowi],' <- fabs((', 
        gsub('param', paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] + output_hsd_',ctspec$param[rowi]),ctspec$transform[rowi]), ' - ',
        gsub('param', paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] - output_hsd_',ctspec$param[rowi]),ctspec$transform[rowi]),')/2); \n')
  )
})),collapse=''),'


',if(n.TIpred > 0) paste0(unlist(lapply(1:n.TIpred,function(tip){
paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
  if(ctspec$indvarying[rowi] & ctspec[,paste0(TIpredNames[tip],'_effect')][rowi]) paste0('
    output_tip_',TIpredNames[tip], '_on_', ctspec$param[rowi],' <- ',
    'tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']; \n',
    if(!is.na(ctspec$transform[rowi])) paste0('output_tip_', TIpredNames[tip], '_on_', ctspec$param[rowi],' <- ((', 
      gsub('param', 
        paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] + tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']'),
        ctspec$transform[rowi]), 
      ' - ',
      gsub('param', 
        paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] - tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']'),
        ctspec$transform[rowi]),')/2); \n')
  )
})),collapse='')
})),collapse=''),'
    
    }')

  out<-stanmodelobj
  
  datalong[,'dT'][datalong[,'dT']==0] <- .22
  
  if(fit==TRUE){
   
    
    standata<-list(
      Y=cbind(datalong[,manifestNames]),
      subject=datalong[,'id'],
      nsubjects=nsubjects,
      nmanifest=n.manifest,
      T0check=T0check,
      indvaryingindex=which(ctspec$indvarying[is.na(ctspec$value)]),
      continuoustime=sum(continuoustime),
      nlatent=n.latent,
      ntipred=n.TIpred,
      ntdpred=n.TDpred,
      nparams=nparams,
      nindvarying=nindvarying,
      IIparams = diag(nparams),
      ndatapoints=nrow(datalong),
      padeC=rbind(c(120, 60, 12, 1, 0, 0, 0, 0, 0, 0), c(30240, 
        15120, 3360, 420, 30, 1, 0, 0, 0, 0), c(17297280, 
          8648640, 1995840, 277200, 25200, 1512, 56, 1, 0, 
          0), c(17643225600, 8821612800, 2075673600, 302702400, 
            30270240, 2162160, 110880, 3960, 90, 1)),
      padeCbig= c(64764752532480000, 32382376266240000, 7771770303897600, 
        1187353796428800, 129060195264000, 10559470521600, 
        670442572800, 33522128640, 1323241920, 40840800, 
        960960, 16380, 182, 1),
      dT=array(datalong[,'dT'],dim=nrow(datalong)),
      intervalChange=array(datalong[,'intervalChange'],dim=nrow(datalong)),
      nobs_y=array(apply(datalong[,manifestNames,drop=FALSE],1,function(x) length(x[x!=99999])),dim=nrow(datalong)),
      whichobs_y=matrix(t(apply(datalong[,manifestNames,drop=FALSE],1,function(x) {
        out<-as.numeric(which(x!=99999))
        if(length(out)==0) out<-rep(0,n.manifest)
        if(length(out)<n.manifest) out<-c(out,rep(0,n.manifest-length(out)))
        out
      }) ),nrow=c(nrow(datalong),ncol=n.manifest)))
    
    if(n.TIpred > 0) standata$tipreds <- tipreds
    
    if(n.TDpred > 0) standata<-c(standata,list(tdpreds=array(tdpreds,dim=c(nrow(tdpreds),ncol(tdpreds)))))
    

    control<-list(adapt_delta=.8,
      # adapt_term_buffer=100,
      adapt_init_buffer=2,
      adapt_window=2,
      # adapt_kappa=.95,
      # adapt_gamma=.01,
      # metric="dense_e",
      max_treedepth=12,stepsize=.01)
    
    stanseed<-floor(runif(1,1,99999))
    if(plot==TRUE) {
      stanplot(chains=chains,seed=stanseed)
    }
    if(!exists('sample_file')){
      if(plot==TRUE) sample_file<-paste0(stanseed,'samples.csv')
      if(plot==FALSE) sample_file<-NULL
    }
    
    out <- stan(model_code = c(stanmodelobj), 
      enable_random_init=TRUE,init_r=.5,
      refresh=20,
      data = standata, chains = ifelse(optimize==FALSE & vb==FALSE,chains,0), control=control,
       sample_file=sample_file,
      cores=max(c(chains,detectCores())),...) 
    
 
    
    if(optimize==FALSE & vb==FALSE){ #summarise
      if(plot==TRUE) {
        for(chaini in 1:chains) system(paste0("rm ",stanseed,"samples.csv",chaini))
        system(paste0('rm stanplottemp.R'))
      }
    }
    
    if(optimize==TRUE && fit==TRUE) {
      out <- optimizing(object = out@stanmodel, 
        # init=0,
        # algorithm='BFGS',
        as_vector=F,
        history_size=10,
        # init_alpha=.001,
        tol_obj=1e-14, tol_grad=1e-14,tol_param=1e-14,tol_rel_grad=0, tol_rel_obj=0,
        data = standata, iter=120000,verbose = verbose)
      
      
    }
    
    if(vb==TRUE && fit==TRUE) {
      out <- vb(object = out@stanmodel, 
        iter=iter,
        data = standata,...)
      
    }
    
  } # end if fit==TRUE
  
  
  
  return(out)
      }
