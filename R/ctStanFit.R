#' ctStanFit
#'
#' Fits a ctsem model specified via \code{\link{ctModel}} with type either 'stanct' or 'standt', using Bayseian inference software
#' Stan. 
#' 
#' @param datalong long format data containing columns for subject id (numeric values, 1 to max subjects), manifest variables, 
#' any time dependent (i.e. varying within subject) predictors, 
#' and any time independent (not varying within subject) predictors.
#' @param ctstanmodelobj model object as generated by \code{\link{ctModel}} with type='stanct' or 'standt', for continuous or discrete time
#' models respectively.
#' @param stanmodelobj already specified Stan model object, generally leave NA unless modifying Stan model directly.
#' @param kalman logical indicating whether or not to integrate over latent states using a Kalman filter. 
#' Generally recommended to set TRUE unless using non-gaussian measurement model.
#' @param binomial logical indicating the use of binomial rather than Gaussian data, as with IRT analyses.
#' @param densehyper logical indicating whether to estimate a prior for correlations between parameters, or fix it to 0.
#' @param fit If TRUE, fit specified model using Stan, if FALSE, return stan model object without fitting.
#' @param plot if TRUE, a Shiny program is launched upon fitting to interactively plot samples. 
#' May struggle with many (e.g., > 5000) parameters, and may leave sample files in working directory if sampling is terminated.
#' @param noncentered if FALSE, sample subject level parameters directly, if TRUE, sample subject level parameters as
#' deviations from the estimated population mean. TRUE seems to result in somewhat more effective sampling, 
#' based on limited testing.
#' @param adapt_delta Stan control parameter denoting acceptance ratio to aim for. Increasing is meant to be useful
#' as a way to decrease divergent transitions, but I've not observed this for these models.
#' @param stdnorm logical indicating whether to rely on transformations to standard normal internally. Included for internal testing
#' purposes.
#' @param estmeans Whether to sample parameters for the population means or approximate this 
#' by computing the mean from subject level parameters.
#' @param estsd  Whether to sample parameters for the population standard deviations or approximate this 
#' by computing them from subject level parameters.
#' @param estcorr Whether to sample parameters for the population correlation parameters or approximate them 
#' from subject level parameters. If TRUE, estimation may be much slower and more problematic, thus the default is FALSE.
#' @param asymdiffusion if TRUE, increases fitting speed at cost of model flexibility - T0VAR in the model specification is ignored, the DIFFUSION matrix specification is used as the 
#' asymptotic DIFFUSION matrix (Q*_inf in the vignette / paper) (making it difficult if not impossible to properly specify
#' higher order processes). The speed increases come about because the internal Kalman filter routine has many steps removed, and the
#' asymptotic diffusion parameters are less dependent on the DRIFT matrix.
#' @param max_treedepth Stan control parameter, may be worth increasing if many post-warmup iterations reach max treedepth.
#' @param optimize if TRUE, use Stan's optimizer for maximum a posteriori estimates. Not recommended unless
#' no parameters vary across subjects.
#' @param vb if TRUE, use Stan's variational approximation. Rudimentary testing suggests it is not accurate at present.
#' @param iter number of iterations, half of which will be devoted to warmup by default.
#' @param inits vector of parameter start values, as returned by the rstan function \code{\link{unconstrain_pars}} for instance. 
#' @param initwithoptim generate initial values using a penalised maximum likelihood fit via BFGS.
#' @param chains number of chains to sample.
#' @examples
#' \dontrun{
#' ### Single latent process, measured by 1 indicator, 50 subjects, 
#' ### 20 time points, varying intercepts for indicators, single
#' ### time independent predictor.
#' 
#' set.seed(2)
#' 
#' #Specify a ctsem model of type 'omx' for data generation
#' Tpoints<-20
#' 
#' gm<-ctModel(type='omx', n.latent=1, n.manifest=1, Tpoints=Tpoints,
#' LAMBDA=diag(1), DRIFT=diag(-.4,1), CINT=diag(0,1),
#'  MANIFESTMEANS=matrix(0,nrow=1,ncol=1),
#'  TRAITVAR=diag(1,1),
#'  n.TIpred=1,
#'  TIPREDEFFECT = diag(.5,1), TIPREDVAR = diag(2,1),
#'  MANIFESTVAR=t(chol(diag(.1,1))), DIFFUSION=t(chol(diag(5,1))))
#' 
#' cd<-ctGenerate(gm, n.subjects=50, burnin=300) #generate data
#' 
#' ctIndplot(cd, n.subjects=6, Tpoints=Tpoints, n.manifest=1) #plot a few subjects
#' 
#' #### generate continuous time ctstan model
#' checkm<-ctModel(type='stanct', n.latent=1, n.manifest=1, LAMBDA=diag(1)) 
#'  
#'  #### plot the population priors and some example subject level priors
#'  ctStanPlotPriors(checkm, wait=FALSE) 
#'  
#'  #### Convert ctsem wide format data (used with type = 'omx') 
#'  #### to appropriate long format
#' long<-ctWideToLong(cd,Tpoints,n.manifest=checkm$n.manifest,
#' manifestNames = checkm$manifestNames, n.TDpred=checkm$n.TDpred,
#' n.TIpred=checkm$n.TIpred, TDpredNames = checkm$TDpredNames,
#' TIpredNames = checkm$TIpredNames)
#'   
#' long<-ctDeintervalise(long) # Convert from time intervals to absolute time
#' 
#' #Set all parameters except the manifest means to be fixed across subjects
#' checkm$parameters$indvarying[-6]<-FALSE
#' 
#' #Fit the model to the data using 200 iterations, 2 chains and 
#' #plotting the fit progress.
#' fit<-ctStanFit(long, checkm, iter=200, chains=2, plot=TRUE)
#' 
#' #traceplot output parameters
#' traceplot(fit, 
#' fit@model_pars[grep('output',fit@model_pars)], 
#' inc_warmup=FALSE) 
#' 
#' #density plot output parameters
#' stan_dens(fit,c('lp__',
#' fit@model_pars[grep('output',fit@model_pars)]),
#' inc_warmup=FALSE) 
#' 
#' s<-summary(fit) #construct summary using stan summary function
#' 
#' #### display rows of summary relevant to output parameters
#' s$summary[c(grep('output',rownames(s$summary)),grep('lp',rownames(s$summary))),
#'   c('mean','sd','n_eff','Rhat')] 
#' 
#' ####shinystan provides a web gui for exploring the samples
#' #require(shinystan) 
#' #launch_shinystan(fit)
#' 
#' #### generate and plot subject specific estimates 
#' #### for subjects 2 and 3, using the Kalman filter
#' pred<-ctStanPredictions(ctstanmodelobj=checkm,
#' ctstanfitobj=fit, subjects=c(2,3), datalong=long)
#' 
#' plot(pred[[2]]$y, type='b', lwd=1, lty=3,col='red')
#' points(pred[[2]]$ysmooth, type='b', col='red', lwd=2)
#' points(pred[[3]]$y, type='b', lwd=1, lty=3,col='blue')
#' points(pred[[3]]$ysmooth, type='b', col='blue', lwd=2)
#' }
#' @export
ctStanFit<-function(datalong, ctstanmodelobj, stanmodelobj=NA, iter=2000, kalman=TRUE, binomial=FALSE, densehyper=TRUE,
  fit=TRUE, plot=FALSE, noncentered=TRUE, adapt_delta=.8, stdnorm=TRUE, max_treedepth=10, estmeans=TRUE, estsd=TRUE, estcorr=FALSE,
  asymdiffusion=FALSE,optimize=FALSE, vb=FALSE, chains=1,inits=NULL,initwithoptim=FALSE,...){

  fixedkalman=FALSE
  tmpdir=tempdir()
  tmpdir=gsub('\\','/',tmpdir,fixed=T)
  # fixedkalman=FALSE
  
  if(fixedkalman & !kalman) stop('fixedkalman estimation only possible using Kalman filter, for now')
  if(fixedkalman & !asymdiffusion) stop('fixedkalman needs asymdiffusion=TRUE!')
  
  
  stanplot<-function(chains,seed){
    wd<-  paste0("setwd('",tmpdir,"')")
    writeLines(text=paste0(wd,'
      seed<-',seed,';
      chains<-',chains,';
      iter<-',iter,';
      
      notyet<-TRUE
      while(notyet==TRUE){
      Sys.sleep(10);
      samps<-try(read.csv(file=paste0(seed,"samples.csv",1),comment.char="#"))
      if(class(samps) != "try-error") notyet<-FALSE
      }
      varnames<-colnames(samps);
      require(shiny); 
      shiny::runApp(appDir=list(server=function(input, output,session) {
      
      output$chainPlot <- renderPlot({
      parameter<-input$parameter
      begin<-input$begin
      colimport<-rep("NULL",length(varnames))
      colimport[which(varnames %in% parameter)]<-NA
      begin<-input$begin
      samps<-list()
      for(chaini in 1:chains) {
      samps[[chaini]]<-read.csv(file=paste0(seed,"samples.csv",chaini),comment.char="#",colClasses = colimport)
      }
      
      mini<-min(unlist(lapply(1:chains,function(chaini) samps[[chaini]][-1:-begin,parameter])),na.rm=T)
      maxi<-max(unlist(lapply(1:chains,function(chaini) samps[[chaini]][-1:-begin,parameter])),na.rm=T)
      lengthi<-max(unlist(lapply(1:chains,function(chaini) length(samps[[chaini]][,parameter]))),na.rm=T) #-1:-begin
      
      plot((begin):(lengthi+begin-1),
      c(samps[[1]][-1:-begin,parameter],rep(NA,lengthi-length(samps[[1]][-1:-begin,parameter]))),
      type="l",xlab="",ylab="",main=parameter,
      log=ifelse(parameter %in% c("stepsize__"),"y",""),
      xlim=c(begin,lengthi),
      ylim=c(mini,maxi)
      )
      
      if(chains > 1) for(chaini in 2:chains){
      points(begin:(lengthi+begin-1),c(samps[[chaini]][-1:-begin,parameter],rep(NA,lengthi-length(samps[[chaini]][-1:-begin,parameter]))),type="l",xlab="",ylab="",main=parameter,col=chaini)
      }
      grid()
      
      })
      },ui=fluidPage(
      # Application title
      titlePanel("ctsem mid-sampling plots..."),
      sidebarLayout(
      # Sidebar with a slider input for number of observations
      sidebarPanel(
      sliderInput("begin", "Start of range:", min = 1,max=iter,value = 1,step=1), 
      selectInput("parameter", "Choose a parameter:", choices = varnames),
      actionButton("refresh", "Refresh sample data")
      ),
      
      # Show a plot of the generated distribution
      mainPanel(
      plotOutput("chainPlot")
      )
      ))),
      launch.browser=TRUE)
      quit(save="no")'),con=paste0(tmpdir,"/stanplottemp.R"))
    system(paste0("Rscript.exe --slave --no-restore -e source('",tmpdir,"/stanplottemp.R')"),wait=F)
    
  }
  
  
  
  checkvarying<-function(matrixnames,yesoutput,nooutput=''){#checks if a matrix is set to individually vary in ctspec
    check<-0
    out<-nooutput
    for( matname in matrixnames){
      if(any(ctspec$indvarying[ctspec$matrix %in% matrixnames])) check<-c(check,1)
    }
    if(sum(check)==length(matrixnames))  out<-yesoutput
    return(out)
  }
  
  
  #read in ctmodel values
  ctspec<-ctstanmodelobj$parameters
  
  if(binomial) {
    ctspec<-ctspec[ctspec$matrix != 'MANIFESTVAR',]
    message(paste0('MANIFESTVAR matrix is ignored when binomial=TRUE'))
  }
  
  # if(!kalman) {
  #   message('ATTENTION: T0VAR matrix is ignored when kalman=FALSE  \n')
  #   ctspec<-ctspec[-which(ctspec$matrix %in% 'T0VAR'),]
  #   if(any(!is.na(ctspec[ctspec$matrix %in% 'T0MEANS','value']))) message('ATTENTION: Some T0MEANS are fixed - may be unwanted when kalman=FALSE \n')
  # }
  
  #clean ctspec structure
  for(rowi in 1:nrow(ctspec)){
    if( !is.na(ctspec$value[rowi])) {
      found<-TRUE
      ctspec[rowi,c('param','transform','indvarying')]<-c(NA,NA,FALSE)
    }
  }
  if(found) message('Inconsistencies in model found - removing param name, transform and indvarying from any parameters with a value specified')
  
  
  n.latent<-ctstanmodelobj$n.latent
  n.manifest<-ctstanmodelobj$n.manifest
  n.TDpred<-ctstanmodelobj$n.TDpred
  n.TIpred<-ctstanmodelobj$n.TIpred
  
  manifestNames<-ctstanmodelobj$manifestNames
  latentNames<-ctstanmodelobj$latentNames
  TDpredNames<-ctstanmodelobj$TDpredNames
  TIpredNames<-ctstanmodelobj$TIpredNames
  id<-ctstanmodelobj$subjectIDname
  timeName<-ctstanmodelobj$timeName
  continuoustime<-ctstanmodelobj$continuoustime
  indvarying<-ctspec$indvarying
  nindvarying<-sum(indvarying)
  nparams<-sum(is.na(ctspec$value))
  
  
  #data checks
  if(any(is.na(as.numeric(datalong[,id])))) stop('id column may not contain NA\'s or character strings!')
  
  #fit spec checks
  if(binomial & any(kalman)) stop('Binomial observations only possible with kalman=FALSE')
  
  
  T0check<-1
  for(i in 2:nrow(datalong)){
    T0check<-c(T0check, ifelse(datalong[,'id'][i] != datalong[,'id'][i-1], 1, 0))
  }
  
  if(any(is.na(datalong[,timeName]))) stop('Missing "time" column!')
  
  #check id and calculate intervals, discrete matrix indices
  driftindex<-rep(0,nrow(datalong))
  diffusionindex<-driftindex
  cintindex<-driftindex
  oldsubi<-0
  dT<-rep(-1,length(datalong[,timeName]))
  # intervalChange<-dT
  for(rowi in 1:length(datalong[,timeName])) {
    subi<-datalong[rowi,id]
    if(rowi==1 && subi!=1) stop('subject id column must ascend from 1 to total subjects without gaps')
    if(oldsubi!=subi && subi-oldsubi!=1) stop('subject id column must ascend from 1 to total subjects without gaps')
      if(subi - oldsubi == 1) {
        dT[rowi]<-0
        subistartrow<-rowi
      }
      if(subi - oldsubi == 0) {
        if(continuoustime) dT[rowi]<-datalong[rowi,timeName] - datalong[rowi-1,timeName]
        if(!continuoustime) dT[rowi]<-1
        if(dT[rowi] <=0) stop(paste0('A time interval of ', dT[rowi],' was found at row ',rowi))
        # if(subi!=oldsubi) intervalChange[rowi] <-  0
        # if(subi==oldsubi && dT[rowi] != dT[rowi-1]) intervalChange[rowi] <- 1
        # if(subi==oldsubi && dT[rowi] == dT[rowi-1]) intervalChange[rowi] <- 0
        if(dT[rowi] %in% dT[1:(rowi-1)]) dTinwhole<-TRUE else dTinwhole<-FALSE
        if(dT[rowi] %in% dT[subistartrow:(rowi-1)]) dTinsub<-TRUE else dTinsub<-FALSE
        
        if(checkvarying('DRIFT',1,0)==0 & dTinwhole==FALSE) driftindex[rowi] <- max(driftindex)+1
        if(checkvarying('DRIFT',1,0)==1 & dTinsub==FALSE) driftindex[rowi] <- max(driftindex)+1
        if(checkvarying('DRIFT',1,0)==0 & dTinwhole==TRUE) driftindex[rowi] <- driftindex[match(dT[rowi],dT)]
        if(checkvarying('DRIFT',1,0)==1 & dTinsub==TRUE) driftindex[rowi] <- driftindex[subistartrow:rowi][match(dT[rowi],dT[subistartrow:rowi])]
        
        if(checkvarying(c('DIFFUSION','DRIFT'),1,0)==0 & dTinwhole==FALSE) diffusionindex[rowi] <- max(diffusionindex)+1
        if(checkvarying(c('DIFFUSION','DRIFT'),1,0)==1 & dTinsub==FALSE) diffusionindex[rowi] <- max(diffusionindex)+1
        if(checkvarying(c('DIFFUSION','DRIFT'),1,0)==0 & dTinwhole==TRUE) diffusionindex[rowi] <- diffusionindex[match(dT[rowi],dT)]
        if(checkvarying(c('DIFFUSION','DRIFT'),1,0)==1 & dTinsub==TRUE) diffusionindex[rowi] <- diffusionindex[subistartrow:rowi][match(dT[rowi],dT[subistartrow:rowi])]
        
        if(checkvarying(c('CINT','DRIFT'),1,0)==0 & dTinwhole==FALSE) cintindex[rowi] <- max(cintindex)+1
        if(checkvarying(c('CINT','DRIFT'),1,0)==1 & dTinsub==FALSE) cintindex[rowi] <- max(cintindex)+1
        if(checkvarying(c('CINT','DRIFT'),1,0)==0 & dTinwhole==TRUE) cintindex[rowi] <- cintindex[match(dT[rowi],dT)]
        if(checkvarying(c('CINT','DRIFT'),1,0)==1 & dTinsub==TRUE) cintindex[rowi] <- cintindex[subistartrow:rowi][match(dT[rowi],dT[subistartrow:rowi])]
    }
    oldsubi<-subi
  }
  message('Unique discreteDRIFT calculations per iteration required = ', length(unique(driftindex)))
  message('Unique discreteCINT calculations per iteration required = ', length(unique(cintindex)))
  message('Unique discreteDIFFUSION calculations per iteration required = ', length(unique(diffusionindex)))
  # browser()
  # datalong[sort(c(which(dT > 5),which(dT > 5)+1,which(dT > 5)-1)),1:2]
  
  if(n.TDpred > 0) {
    datalong[,TDpredNames][is.na(datalong[,TDpredNames])] <-0 ## temporary fix for missingness
    if(any(is.na(datalong[,TDpredNames]))) stop('Missingness in TDpreds!')
  }
  if(n.TIpred > 0) {
    if(n.TIpred > 0) tipreds <- datalong[match(unique(datalong[,id]),datalong[,id]),TIpredNames,drop=FALSE]
    if(any(is.na(tipreds))) stop('Missingness in TIpreds!')
  }
  
  datalong[is.na(datalong)]<-99999 #missing data
  
  if(n.TDpred > 0) tdpreds <- datalong[,TDpredNames,drop=FALSE]
  
  nsubjects <- length(unique(datalong[, 'id'])) 
  
  
  
  
  
  
    writemodel<-function(init=FALSE,optimize=FALSE){
    stanmodelobj <- paste0('
      functions{
      
      
      
      
      matrix fillcholcordiag(matrix mat){
      matrix[rows(mat),cols(mat)] out;
      real tempsum;
      out[1,1]=1;
      if(rows(mat) > 1){
      for(rowi in 2:rows(out)){
      tempsum=0;
      for(coli in 1:(rowi-1)){
      out[rowi,coli]=mat[rowi,coli];
      out[coli,rowi] = 0;
      tempsum = tempsum + mat[rowi,coli]^2;
      }
      out[rowi,rowi]=sqrt(fabs(1-tempsum));
      }
      }
      return out;
      }
      
      
      
      matrix varmatrixtransform(matrix mat,int chol){
      int ndim;
      matrix[rows(mat),cols(mat)] mscale;
      matrix[rows(mat),cols(mat)] mcholcor;
      matrix[rows(mat),cols(mat)] mchol;
      matrix[rows(mat),cols(mat)] out;
      ndim = cols(mat);
      for(coli in 1:ndim){
      for(rowi in 1:ndim){
      
      if(rowi==coli) {
      mscale[rowi,coli] =  mat[rowi,coli];
      }
      
      if(rowi > coli){
      mscale[rowi,coli] =0;
      mscale[coli,rowi] =0;
      mcholcor[rowi,coli] =  mat[rowi,coli]; 
      }
      }}
      mcholcor = fillcholcordiag(mcholcor);
      out = mscale * mcholcor; //cholesky
      if(chol == 0) out=multiply_lower_tri_self_transpose(out) ; //cov
      return out;
      }
      
      
      matrix varmatrixtransform2(matrix mat,int chol){ //converts from cor and sd to chol or cov
      int ndim;
      matrix[rows(mat),cols(mat)] mscale;
      matrix[rows(mat),cols(mat)] mcholcor;
      matrix[rows(mat),cols(mat)] out;
      real tempsum;
      
      ndim = cols(mat);
      mcholcor[1,1]=1;
      mscale = diag_matrix(diagonal(mat));
      
      for(coli in 1:ndim){
      tempsum=0;
      for(rowi in coli:ndim){
      mcholcor[rowi,coli] =  mat[rowi,coli]; 
      mcholcor[coli,rowi] = 0;
      tempsum = tempsum + mcholcor[rowi,coli]^2;
      }
      mcholcor[coli,coli]=sqrt(fabs(1-tempsum));
      }
      
      out = mscale * mcholcor; //cholesky
      if(chol == 0) out=multiply_lower_tri_self_transpose(out) ; //cov
      return out;
      }
      
      
      matrix expmp(matrix A, matrix padeC, vector padeCbig){
      int n;
      real nA;
      real colsum;
      int l;
      matrix[4,10] C;
      vector[4] t;
      matrix[rows(A),rows(A)] I;
      matrix[rows(A),rows(A)] P;
      matrix[rows(A),rows(A)] U;
      matrix[rows(A),rows(A)] V;
      matrix[rows(A),rows(A)] X;
      
      vector[14] Cbig;
      real s;
      real si;
      matrix[rows(A),rows(A)] B;
      matrix[rows(A),rows(A)] B2;
      matrix[rows(A),rows(A)] B4;
      matrix[rows(A),rows(A)] B6;
      matrix[rows(A),rows(A)] A2;
      
      si = 0;
      C = padeC;
      Cbig = padeCbig;
      
      n =rows(A);
      if(n != cols(A)) print("expmp: Matrix not square!")
      
      // if (n <= 1) X = exp(A);
      if(sum(A)==sum(diagonal(A))) X = diag_matrix(exp(diagonal(A)));
      else{
      
      // nA = Matrix::norm(A, "1")
      nA = 0;
      for(coli in 1:n){
      colsum=0;
      for(rowi in 1:n){
      colsum=colsum+fabs(A[rowi,coli]);
      }
      if(colsum > nA) nA = colsum;
      }
      
      I = diag_matrix(rep_vector(1,n));
      if (nA <= 2.1) {
      t[1] = 0.015; t[2]= 0.25; t[3]= 0.95; t[4]= 2.1;
      
      //l = which.max(nA <= t)
      for(ti in 1:4){
      if(l==0){
      if(nA <= t[ti]) l = ti;
      }
      }
      
      A2 = A * A;
      P = I;
      U = C[l, 2] * I;
      V = C[l, 1] * I;
      for (k in 1:l) {
      P = P * A2;
      U = U + C[l, (2 * k) + 2] * P;
      V = V + C[l, (2 * k) + 1] * P;
      }
      U = A * U;
      X = inverse(V - U) * (V + U);
      }
      
      else {
      s = log2(nA/5.4);
      B = A;
      if (s > 0) {
      s = ceil(s);
      B = B/(2^s);
      }
      
      B2 = B * B;
      B4 = B2 * B2;
      B6 = B2*B4;
      U = B*(B6*(Cbig[14] * B6 + Cbig[12] * B4 + Cbig[10] * B2) + Cbig[8] * B6 + Cbig[6] * B4 + Cbig[4] * B2 + Cbig[2] * I);
      V = B6*(Cbig[13] * B6 + Cbig[11] * B4 + Cbig[9] * B2) + Cbig[7] * B6 + Cbig[5] * B4 + Cbig[3] * B2 + Cbig[1] * I;
      X = inverse(V - U) * (V + U);
      
      if (s > 0) {
      while (si < s){ 
      si = si + 1;
      X = X * X;
      }
      }
      }
      
      }
      return X;
      }
      
      vector vecsqrt(vector in) {
      vector[num_elements(in)] out;
      for (i in 1:num_elements(in)){
      out[i] = sqrt(in[i]);
      }
      return out;
      }
      
      
      
      matrix kron_prod(matrix mata, matrix matb){
      int m;
      int p;
      int n;
      int q;
      matrix[rows(mata)*rows(matb),cols(mata)*cols(matb)] C;
      m=rows(mata);
      p=rows(matb);
      n=cols(mata);
      q=cols(matb);
      for (i in 1:m){
      for (j in 1:n){
      for (k in 1:p){
      for (l in 1:q){
      C[p*(i-1)+k,q*(j-1)+l] = mata[i,j]*matb[k,l];
      }
      }
      }
      }
      return C;
      }
      
      matrix makesym(matrix mat){
      matrix[rows(mat),cols(mat)] out;
      out=mat;
      for(rowi in 1:rows(mat)){
      for(coli in 1:cols(mat)){
      if(coli > rowi) out[rowi,coli]=out[coli,rowi];
      }
      }
      return out;
      }
      
      
      matrix cov(vector[] mat,int nrows,int ncols){
      vector[ncols] means;
      matrix[nrows,ncols] centered;
      matrix[ncols,ncols] cov;
      for (coli in 1:ncols){
      means[coli] = mean(mat[,coli]);
      for (rowi in 1:nrows)  {
      centered[rowi,coli] = mat[rowi,coli] - means[coli];
      }
      }
      cov = centered\' * centered / (nrows-1);
      return cov; 
      }
      
      matrix cov2cor(matrix cov,int dim){
      matrix[dim,dim] cor;
      cor = inverse(diag_matrix(vecsqrt(diagonal(cov)))) * cov * inverse(diag_matrix(vecsqrt(diagonal(cov))));
      return(cor);
      }
      
      
      
      }
      data {
      matrix[4,10] padeC; // for matrix exponential
      vector[14] padeCbig;
      int<lower=0> ndatapoints;
      int<lower=1> nmanifest;
      int<lower=1> nlatent;
      int<lower=1> nsubjects;
      
      ',if(n.TIpred > 0) paste0('int<lower=0> ntipred; // number of time independent covariates
        matrix[nsubjects,ntipred] tipreds; '),'
      
      ',if(!binomial) 'vector[nmanifest] Y[ndatapoints]; \n',
      if(binomial) 'int Y[ndatapoints,nmanifest]; \n','
      int<lower=0> ntdpred; // number of time dependent covariates
      
      ',if(n.TDpred > 0) paste0('vector[ntdpred] tdpreds[ndatapoints];'),'
      
      vector[ndatapoints] dT; // time intervals
      int driftindex[ndatapoints]; //which discreteDRIFT matrix to use for each time point
      int diffusionindex[ndatapoints]; //which discreteDIFFUSION matrix to use for each time point
      int cintindex[ndatapoints]; //which discreteCINT matrix to use for each time point
      int subject[ndatapoints];
      int<lower=0> nparams;
      int T0check[ndatapoints]; // logical indicating which rows are the first for each subject
      int continuoustime; // logical indicating whether to incorporate timing information
      int nindvarying; // number of subject level parameters that are varying across subjects
      ',if(nindvarying>0) paste0('int indvaryingindex[nindvarying]',';
        vector[nindvarying] sdscale;'),'
    
      vector[nlatent] stationarymeanprior; // prior std dev for difference between process asymptotic mean and initial mean
      vector[nlatent] stationaryvarprior; // prior std dev for difference between process asymptotic variance and initial variance
      
      int<lower = 0, upper = nmanifest> nobs_y[ndatapoints];  // number of observed variables per observation
      int<lower = 0, upper = nmanifest> whichobs_y[ndatapoints, nmanifest]; // index of which variables are observed per observation
      }
      
      transformed data{
      matrix[nlatent,nlatent] IIlatent;
',if(init & nindvarying >0) 'vector[nindvarying] hypersd;','
      IIlatent = diag_matrix(rep_vector(1,nlatent));
      ',if(init & nindvarying >0) 'hypersd[1:nindvarying] = rep_vector(1,nindvarying);','
     

      }
      
      parameters {
      
      vector[nparams] hypermeansbase; // subject level parameter means \n','
      
      ',if(any(indvarying)) paste0(
        'vector[nindvarying] indparams[nsubjects]; //subject level parameters
        ',if(!init & (estsd | 1==1)) 'vector[nindvarying] hypersdbase; // population sd of any varying subject level parameters
        '),'
      
      ',if(any(indvarying) & densehyper & estcorr) paste0('vector[(nindvarying*nindvarying-nindvarying)/2] hypercorrparsbase;'),'
      
      ',if(n.TIpred > 0) paste0('vector[',sum(unlist(ctspec[,paste0(TIpredNames,'_effect')])),'] tipredeffectparams; // effects of time independent covariates\n'),'

',if(!kalman)  'vector[nlatent] etapost[ndatapoints]; //sampled latent states posterior','

      
      }
      
      transformed parameters{
      vector[nparams] hypermeans;
      
      
      ',if(any(indvarying) & densehyper==TRUE) 'matrix[nindvarying,nindvarying] hypercorr;
      
      vector[(nindvarying*nindvarying-nindvarying)/2] hypercorrpars; \n','
      
      ',if(any(nindvarying)) paste0('
        ',if(!init) 'vector[nindvarying] hypersd;','
        matrix[nindvarying,nindvarying] paramcov;
        matrix[nindvarying,nindvarying] paramcor;
        
        matrix[nindvarying,nindvarying] paramchol; //cholesky of population covariance of varying subject parameters','
        ',if(stdnorm==TRUE) 'matrix[nindvarying,nindvarying] invparamchol; //just storing the inverse
        vector[nindvarying*nsubjects] indparamstrans; // transformation of subject level parameters to standard normal dist \n'),'
      
      matrix[nlatent,nlatent] DIFFUSION',checkvarying('DIFFUSION','[nsubjects]','[1]'),'; //additive latent process variance
      ',if(1==1 || kalman) paste0('matrix[nlatent,nlatent] T0VAR',checkvarying('T0VAR','[nsubjects]','[1]'),'; //initial latent process variance'),'
      matrix[nlatent,nlatent] DRIFT',checkvarying('DRIFT','[nsubjects]','[1]'),'; //dynamic relationships of processes
      ',if(continuoustime) paste0('matrix[nlatent,nlatent] invDRIFT',checkvarying('DRIFT','[nsubjects]','[1]'),'; \n'),'
      ',if(!binomial) paste0('matrix[nmanifest,nmanifest] MANIFESTVAR',checkvarying('MANIFESTVAR','[nsubjects]','[1]'),'; // manifest error variance'),'
      vector[nmanifest] MANIFESTMEANS',checkvarying('MANIFESTMEANS','[nsubjects]','[1]'),';
      vector[nlatent] T0MEANS',checkvarying('T0MEANS','[nsubjects]','[1]'),'; // initial (T0) latent states
      matrix[nmanifest,nlatent] LAMBDA',checkvarying('LAMBDA','[nsubjects]','[1]'),'; // loading matrix
      vector[nlatent] CINT',checkvarying('CINT','[nsubjects]','[1]'),'; // latent process intercept
      ',if(!asymdiffusion) paste0('matrix[nlatent,nlatent] asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[nsubjects]','[1]'),'; //latent process variance as time interval goes to inf'),'
      
      ',if(n.TDpred > 0) paste0('matrix[nlatent,ntdpred] TDPREDEFFECT',checkvarying('TDPREDEFFECT','[nsubjects]','[1]'),'; // effect of time dependent predictors'),'
      ',if(n.TIpred > 0) paste0('matrix[',nindvarying,',',n.TIpred,'] tipredeffect; //design matrix of individual time independent predictor effects'),'
      
      ',if(n.TIpred > 0) paste0(unlist(lapply(1,function(x){ ## collects all the time independent predictors effects into the design matrix
        count<-0
        tirow<-0
        out<-c()
        for(rowi in 1:nrow(ctspec[,])){
          if(is.na(ctspec$value[rowi]) & ctspec$indvarying[rowi]) {
            tirow<-tirow+1
            for(predi in 1:n.TIpred){
              if(ctspec[rowi, paste0(TIpredNames[predi],'_effect')] == FALSE) out<-c(out, ' tipredeffect[',tirow,', ', predi,'] = 0; \n')
              if(ctspec[rowi, paste0(TIpredNames[predi],'_effect')] == TRUE) {
                count<-count+1
                out<-c(out, ' tipredeffect[',tirow,', ', predi,'] = tipredeffectparams[',count,']; \n ')
              }
            }
          }}
        return(out)
      })),collapse=''),'

      
      ',paste0('hypermeans = hypermeansbase;
        ',if(!estmeans & nindvarying > 0) paste0('for(parami in 1:nindvarying){
          hypermeans[indvaryingindex[parami]] = mean(indparams[,parami]) + hypermeansbase[indvaryingindex[parami]];
        }')),'
      
      
      
      ',if(any(indvarying)) paste0('
        paramcov = cov(indparams,nsubjects,nindvarying);
        paramcor = cov2cor(paramcov,nindvarying);
        ',if(!estsd & !init) 'hypersd = log(vecsqrt(diagonal(paramcov))) + hypersdbase;','
        ',if(estsd & !init) 'hypersd = hypersdbase;'),'
      
      
      ',if(any(indvarying) & densehyper==TRUE) paste0(
        '{ // compute correlation and sd matrix of subject params
        int parcount;
        parcount = 0;
        for(rowi in 1:nindvarying){
        for(coli in 1:nindvarying){
        if(rowi > coli) {
        parcount = parcount+1;
        hypercorrpars[parcount] = -log(2/(paramcor[rowi,coli]+1) -1)', if(estcorr) ' + hypercorrparsbase[parcount] ',';
        hypercorr[rowi,coli] = 2/(1+exp(-hypercorrpars[parcount]))-1;
        hypercorr[coli,rowi] = hypercorr[rowi,coli];
        }
        if(rowi==coli) hypercorr[rowi,coli]=  ',ctstanmodelobj$hypersdtransform,'; // compute actual std dev from hypersd parameter
        }
        } } \n'),'    
      
      
      ',if(any(ctspec$indvarying)) paste0(
        if(densehyper) 'paramchol = varmatrixtransform2(hypercorr,1); // transform correlation and sd matrix to cholesky decomp cov \n ',
        if(!densehyper) paste0('paramchol=diag_matrix(',ctstanmodelobj$hypersdtransform,');'),
        if(stdnorm & densehyper) 'invparamchol = inverse(paramchol); \n',
        if(stdnorm & !densehyper) 'invparamchol = diag_matrix(1 ./ diagonal(paramchol));'),'
      
      {
      vector[nlatent*nlatent] asymDIFFUSIONvec',checkvarying(c('DIFFUSION','DRIFT'),'[nsubjects]','[1]'),';
      ',if(continuoustime & !asymdiffusion) paste0('matrix[nlatent*nlatent,nlatent*nlatent] DRIFTHATCH',checkvarying(c('DRIFT'),'[nsubjects]','[1]'),';'),'
      
      ',if(any(ctspec$indvarying) & stdnorm) paste0('
        for(subi in 1:nsubjects){ // transform subject parameters to standard normal dist
        indparamstrans[(1+(subi-1)*nindvarying):(subi*nindvarying)]=invparamchol * (indparams[subi]',
        if(n.TIpred>0) '-tipredeffect * tipreds[subi]\' ',
        if(!noncentered) '-hypermeans[indvaryingindex]',
        ');
        }
        '),'    
      
      // create subject specific parameter matrices from fixed and transformed free effects 
      ',paste0(unlist(lapply(1:nrow(ctspec),function(rowi) {
        
        x<-paste0(
          checkvarying(ctspec[rowi,'matrix'],'for(subi in 1:nsubjects) '),
          ctspec[rowi,'matrix'], checkvarying(ctspec[rowi,'matrix'],'[subi]','[1]'),'[', ctspec[rowi,'row'], 
          if(ctspec[rowi,'matrix'] %in% c('LAMBDA','DRIFT','DIFFUSION',
            'MANIFESTVAR', 'TDPREDEFFECT', 'T0VAR')) paste0(' , ', ctspec[rowi,'col']),
          ']') 
        
        y<- paste0('(',
          if(is.na(ctspec[rowi,'value']) & (noncentered | !ctspec$indvarying[rowi])) paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),']'),
          if(ctspec[rowi,'indvarying'] & noncentered) ' + ',
          if(ctspec[rowi,'indvarying']) paste0('indparams[subi][',which(ctspec[ctspec$indvarying,'param']==ctspec[rowi,'param']),']')
          ,')')
        
        if(!is.na(ctspec[rowi,'value'])) out<-paste0(x,' = ',ctspec[rowi,'value'],'; \n')
        
        if(!is.na(ctspec$transform[rowi]) & is.na(ctspec$value[rowi])) out<-paste0(
          x, ' = ', gsub('param',y,ctspec$transform[rowi]),'; \n')
        return(out)
        })),collapse=''),
      '
      
      
      // perform any whole matrix transformations 
      
      ',if(!binomial) paste0(
        'for(individual in 1:',checkvarying('MANIFESTVAR','nsubjects','1'),') MANIFESTVAR[individual] = varmatrixtransform2(MANIFESTVAR[individual],0);
        '),'
      
      for(individual in 1:',checkvarying('DIFFUSION','nsubjects','1'),') DIFFUSION[individual] = varmatrixtransform2(DIFFUSION[individual],0);
      ',if(1==1 || kalman) paste0('for(individual in 1:',checkvarying('T0VAR','nsubjects','1'),') T0VAR[individual] = varmatrixtransform2(T0VAR[individual],0);'),'
      
      ',if(continuoustime) paste0('
        for(individual in 1:',checkvarying('DRIFT','nsubjects','1'),') {
        invDRIFT[individual] = inverse(DRIFT[individual]);
        ',if(!asymdiffusion) paste0(
          'DRIFTHATCH[individual] = kron_prod(DRIFT[individual],diag_matrix(rep_vector(1, nlatent))) +  kron_prod(diag_matrix(rep_vector(1, nlatent)),DRIFT[individual]);
          '),'
        }
        
        ',if(!asymdiffusion) paste0('
          for(individual in 1:',checkvarying(c('DIFFUSION','DRIFT'),'nsubjects','1'),'){
          asymDIFFUSIONvec[individual] =  -inverse(DRIFTHATCH',checkvarying(c('DRIFT'),'[individual]','[1]'),') * to_vector(DIFFUSION',checkvarying(c('DIFFUSION'),'[individual]','[1]'),');
          for(drowi in 1:nlatent) {
          for(dcoli in 1:nlatent){
          asymDIFFUSION[individual][drowi,dcoli] =  asymDIFFUSIONvec[individual][drowi+(dcoli-1)*nlatent];
          }}
          asymDIFFUSION[individual] = makesym(asymDIFFUSION[individual]);
          }
          ')),
      
      if(!continuoustime & !asymdiffusion) paste0('
        for(individual in 1:',checkvarying(c('DIFFUSION','DRIFT'),'nsubjects','1'),'){
        asymDIFFUSIONvec[individual] = (diag_matrix(rep_vector(1, nlatent*nlatent)) - kron_prod(DRIFT',checkvarying(c('DRIFT'),'[individual]','[1]'),', DRIFT',checkvarying(c('DRIFT'),'[individual]','[1]'),')) * 
        to_vector(DIFFUSION',checkvarying(c('DIFFUSION'),'[individual]','[1]'),');
        for(drowi in 1:nlatent) {
        for(dcoli in 1:nlatent){
        asymDIFFUSION[individual][drowi,dcoli] =  asymDIFFUSIONvec[individual][drowi+(dcoli-1)*nlatent];
        }}
        }
        '),'
      }
  }
      
      
      model{
      int subjecti;
      int counter;
      matrix[nlatent,nlatent] discreteDRIFT[',max(driftindex),']; 
      vector[nlatent] discreteCINT[',max(cintindex),'];
      ',if(1==1 || !(kalman & fixedkalman)) paste0('matrix[nlatent,nlatent] discreteDIFFUSION[',max(diffusionindex),'];'),'
      
      
      ',if(1==1 || kalman==TRUE) paste0('
        vector[nlatent] etaprior[ndatapoints]; //prior for latent states

        ',if(kalman==TRUE) 'matrix[nlatent, nlatent] etapriorcov[ndatapoints]; //prior for covariance of latent states
        vector[nlatent] etapost[ndatapoints]; //posterior for latent states
        matrix[nlatent, nlatent] etapostcov[ndatapoints]; //posterior for covariance of latent states','

        vector[sum(nobs_y)] errtrans; // collection of prediction errors transformed to standard normal
        int obscount; // counter summing over number of non missing observations in each row
        int nobsi; 
        ',if(fixedkalman) paste0(
          'matrix[nmanifest,nmanifest] Ypredcov;
          matrix[nmanifest,nmanifest] invYpredcov;
          matrix[nmanifest,nmanifest] invYpredcov_chol; 
          matrix[nlatent,nmanifest] K;
          ')),'
      
      ',if(!optimize) paste0('hypermeans~normal(0,1);'),'
        
      ',if(n.TIpred > 0 & !optimize) paste0('tipredeffectparams ~ ',ctstanmodelobj$tipredeffectprior, '; \n '),' 
      
      ',if(any(ctspec$indvarying) & !optimize) paste0(' hypersd ~ ',ctstanmodelobj$hypersdprior,';
        ',if(densehyper & estcorr) 'hypercorrpars ~ normal(0,1);','
        ',if(stdnorm) 'indparamstrans ~ normal(0,1);
        target +=(sum(log(diagonal(invparamchol)))*nsubjects);  //adjust loglik for density warping transform',
        
        if(!stdnorm & !optimize) paste0('
          for(subi in 1:nsubjects){ // transform subject parameters to standard normal dist
          indparams[subi]~multi_normal_cholesky(rep_vector(0,nindvarying) ',
          if(n.TIpred>0) '+ tipredeffect * tipreds[subi]\' ',
          if(!noncentered) '+ hypermeans[indvaryingindex]',
          ',paramchol);
          }
          '),'
        '),' 
      
// pre-calculate necessary discrete time matrices      
      counter=0;
      for(rowi in 1:ndatapoints) if(T0check[rowi]==0 && (rowi==1 || driftindex[rowi] > counter)) { discreteDRIFT[driftindex[rowi]] = ',
      if(!continuoustime) paste0('DRIFT',checkvarying('DRIFT','[subject[rowi]]','[1]'),';'),
      if(continuoustime) paste0('expmp(DRIFT',checkvarying('DRIFT','[subject[rowi]]','[1]'),' * dT[rowi], padeC, padeCbig);'),'
      counter=counter+1;}
      counter=0;
      ',if(!fixedkalman) paste0('for(rowi in 1:ndatapoints) if(T0check[rowi]==0 && (rowi==1 || diffusionindex[rowi] > counter)){ discreteDIFFUSION[diffusionindex[rowi]] = ',
        if(!continuoustime) paste0('DIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),';'),
        if(continuoustime & !asymdiffusion) paste0('asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),' - 
          quad_form(asymDIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),' , discreteDRIFT[driftindex[rowi]]\');'),
        if(continuoustime & asymdiffusion) paste0('DIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),' - 
          quad_form(DIFFUSION',checkvarying(c('DIFFUSION','DRIFT'),'[subject[rowi]]','[1]'),' , discreteDRIFT[driftindex[rowi]]\');'),'
        counter=counter+1;}
        counter=0;
        '),'
      for(rowi in 1:ndatapoints) if(T0check[rowi]==0 && (rowi==1 || cintindex[rowi] > counter)) { discreteCINT[cintindex[rowi]] = ',
      if(!continuoustime) paste0('CINT',checkvarying('CINT','[subject[rowi]]','[1]'),';'),
      if(continuoustime) paste0('invDRIFT',checkvarying('DRIFT','[subject[rowi]]','[1]'),' * (discreteDRIFT[driftindex[rowi]] - IIlatent) * CINT',
        checkvarying('CINT','[subject[rowi]]','[1]'),';'),'
      counter=counter+1;}
      
      
// stationarity priors
      for(individual in 1:nsubjects) {
        (diagonal(',
       if(!asymdiffusion) 'asym', 'DIFFUSION[',
        checkvarying(c('DIFFUSION','DRIFT'),'individual','1'),']) - diagonal(T0VAR[',
        checkvarying('T0VAR','individual','1'),'])) ~ normal(0,stationaryvarprior); // variance stationarity prior
      }

    for(individual in 1:nsubjects) {
      T0MEANS[',checkvarying('T0MEANS','individual','1'),'] - ',
        '( invDRIFT[',checkvarying('DRIFT','individual','1'),'] * CINT[',checkvarying('CINT','individual','1'),'] )',
      ' ~ normal(0,stationarymeanprior); // mean stationarity prior
        }
 
// filtering
        obscount=1;
        for(rowi in 1:ndatapoints){
        int whichobs[nobs_y[rowi]];
        whichobs = whichobs_y[rowi][1:nobs_y[rowi]];
        subjecti=subject[rowi];
        nobsi = nobs_y[rowi];
        
        
        if(rowi!=1) obscount=obscount+nobs_y[rowi-1]; // number of non missing observations until now
        
        ',if(fixedkalman) paste0(
          'if(T0check[rowi]==1 || T0check[rowi-1] ==1){',
          paste0( checkvarying(c('DIFFUSION','LAMBDA','MANIFESTVAR'),'','if(rowi<=2){'),
            'if(T0check[rowi]==1) Ypredcov = quad_form(T0VAR',
            checkvarying('T0VAR','[subjecti]','[1]'),', LAMBDA',
            checkvarying('LAMBDA','[subjecti]','[1]'),'\') + MANIFESTVAR',
            checkvarying('MANIFESTVAR','[subjecti]','[1]'),';
            if(T0check[rowi]==0) Ypredcov = quad_form(DIFFUSION',
            checkvarying('DIFFUSION','[subjecti]','[1]'),', LAMBDA',
            checkvarying('LAMBDA','[subjecti]','[1]'),'\') + MANIFESTVAR',
            checkvarying('MANIFESTVAR','[subjecti]','[1]'),';
            invYpredcov = makesym(inverse(Ypredcov));
            invYpredcov_chol=cholesky_decompose(invYpredcov); 
            K = DIFFUSION',
            checkvarying('DIFFUSION','[subjecti]','[1]'),' * LAMBDA',checkvarying('LAMBDA','[subjecti]','[1]'),'\' * invYpredcov; 
            ',checkvarying(c('DIFFUSION','LAMBDA','MANIFESTVAR'),'','}')),'}'),'
        
        if(T0check[rowi] == 1) { // calculate initial matrices if this is first row for subjecti
        etaprior[rowi] = T0MEANS',checkvarying('T0MEANS','[subjecti]','[1]'),'; //prior for latent state of this row
        ',if(n.TDpred > 0) paste0('etaprior[rowi] =TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi] + etaprior[rowi];'),'
        ',if(kalman & !fixedkalman) paste0('etapriorcov[rowi] =  T0VAR',checkvarying('T0VAR','[subjecti]','[1]'),';'),'

',if(!kalman) paste0('etapost[rowi] ~ multi_normal(etaprior[rowi], T0VAR',checkvarying('T0VAR','[subjecti]','[1]'),');'),'
        }
        
        if(T0check[rowi]==0){
        
        etaprior[rowi] = discreteCINT[cintindex[rowi]]  + discreteDRIFT[driftindex[rowi]] * etapost[rowi-1]; //prior for latent state of this row
        ',if(n.TDpred > 0) paste0('etaprior[rowi] =TDPREDEFFECT',checkvarying('TDPREDEFFECT','[subjecti]','[1]'),' * tdpreds[rowi-1] + etaprior[rowi];'),'
        ',if(kalman && !fixedkalman) paste0('etapriorcov[rowi] =  makesym(quad_form(etapostcov[rowi-1], discreteDRIFT[driftindex[rowi]]\')  + discreteDIFFUSION[diffusionindex[rowi]]);'),'

',if(!kalman) 'etapost[rowi] ~ multi_normal(etaprior[rowi], discreteDIFFUSION[diffusionindex[rowi]]);','
        }


        
        if(nobsi==0){     // if no observations...
        ',if(kalman) 'etapost[rowi] = etaprior[rowi];','
        ',if(kalman && !fixedkalman) paste0('etapostcov[rowi] = etapriorcov[rowi];'),'
        }
        
        if (nobsi > 0) {  // if some observations create right size matrices for missingness and calculate...
        
  ',if(!binomial) paste0('vector[nobsi] Y_filt;
        matrix[nobsi, nlatent] LAMBDA_filt;
        vector[nobsi] MANIFESTMEANS_filt;
        matrix[nobsi, nobsi] MANIFESTVAR_filt;
        vector[nobsi] Ypred_filt;    
        vector[nobsi] err;'),'

        ',if(kalman) paste0('
 matrix[nobsi, nobsi] Ypredcov_filt;
matrix[nlatent, nobsi] K_filt; // kalman gain
        matrix[nobsi, nobsi] invYpredcov_filt;
'),'
',if(!binomial) paste0('
        matrix[nobsi, nobsi] invYpredcov_filt_chol;
        Y_filt = Y[rowi][whichobs]; // filter the data
        MANIFESTMEANS_filt = MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs]; // and manifest means
        LAMBDA_filt = LAMBDA',checkvarying('LAMBDA','[subjecti]','[1]'),'[whichobs]; // and loading matrix
        MANIFESTVAR_filt = MANIFESTVAR',checkvarying('MANIFESTVAR','[subjecti]','[1]'),'[whichobs,whichobs]; // and manifest variance
'),'
        
',if(kalman) '
        Ypred_filt = MANIFESTMEANS_filt + LAMBDA_filt * etaprior[rowi]; // predictions of y given prior
        err = Y_filt - Ypred_filt; // prediction error',
    if(!kalman & !binomial) '
        Ypred_filt = MANIFESTMEANS_filt + LAMBDA_filt * etapost[rowi]; // predictions of y given prior
        err = Y_filt - Ypred_filt; // prediction error','
        
        ',if(kalman && !fixedkalman) paste0(
          'Ypredcov_filt = quad_form(etapriorcov[rowi], LAMBDA_filt\') + MANIFESTVAR_filt;
          invYpredcov_filt = makesym(inverse(Ypredcov_filt)) ;
          invYpredcov_filt_chol=cholesky_decompose(invYpredcov_filt); 
          K_filt = etapriorcov[rowi] * LAMBDA_filt\' * invYpredcov_filt; 
          etapostcov[rowi] = (IIlatent - K_filt * LAMBDA_filt) * etapriorcov[rowi];
          '),'
        
        ',if(fixedkalman) paste0(
          'invYpredcov_filt_chol=invYpredcov_chol[whichobs,whichobs]; 
          K_filt = K[,whichobs]; 
          '),'
        
        ',if(kalman) 'etapost[rowi] = etaprior[rowi] + K_filt * err;','

',if(!kalman & !binomial) 'invYpredcov_filt_chol = diag_matrix( rep_vector(1,nobsi) ./ vecsqrt(diagonal(MANIFESTVAR_filt)));','
        
',if(!binomial) '
        errtrans[obscount:(obscount+nobsi-1)]=invYpredcov_filt_chol*err; //transform pred errors to standard normal dist and collect
        target +=(sum(log(diagonal(invYpredcov_filt_chol)))); //account for transformation of scale in loglik ','

',if(binomial) paste0('Y[rowi][whichobs] ~ bernoulli_logit(LAMBDA',
                  checkvarying('LAMBDA','[subjecti]','[1]'),'[whichobs,] * 
      etapost[rowi] + ', 
    'MANIFESTMEANS',checkvarying('MANIFESTMEANS','[subjecti]','[1]'),'[whichobs]);'),'

        }
        }
        
        ',if(!binomial) 'errtrans~normal(0,1); ','
      
      
      ', if(optimize==TRUE && n.TIpred > 0) paste0('print("tipredeffect ",tipredeffect);'),'
      ', if(optimize==TRUE | vb==TRUE) paste0('
        //print("hypersd",hypersd);
        //print("paramchol",paramchol);
        //print("covariance",cov(indparams,nsubjects,nindvarying));
        //print("cor",cov2cor(cov(indparams,nsubjects,nindvarying),nindvarying));
        //print("hypercorr",hypercorr);
        print("DRIFT ", DRIFT[1]);
        print("DIFFUSION ", DIFFUSION[1]);
        ',if(!fixedkalman) paste0('print("T0VAR ", T0VAR[1]);'),'
        print("MANIFESTVAR ", MANIFESTVAR[1]);
        print("T0MEANS[1] ", T0MEANS[1]);
        print("CINT ", CINT[1]);
        print("MANIFESTMEANS ", MANIFESTMEANS[1]);
        print("lp =",get_lp());
        '),'\n
      
      
        }
      generated quantities{
      
      ',paste0('real output_hmean_',ctspec$param[is.na(ctspec$value)],'; \n',collapse=''),'
      
      ',if(nindvarying > 0) paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
        if(ctspec$indvarying[rowi]) paste0('real output_hsd_',ctspec$param[rowi],'; \n')
      })),collapse=''),'

      ',if(n.TIpred > 0) paste0(unlist(lapply(1:n.TIpred,function(tip){
        paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
          if(ctspec$indvarying[rowi] & ctspec[,paste0(TIpredNames[tip],'_effect')][rowi]) paste0('real output_tip_',
            TIpredNames[tip], '_on_', ctspec$param[rowi],'; \n'
          )
        })),collapse='')
        })),collapse=''),'

      ',paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
        if(is.na(ctspec$value[rowi])) paste0('output_hmean_',ctspec$param[rowi],' = ',
          gsub('param',
            paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),']'),
            ctspec$transform[rowi]),'; \n')
        })),collapse=''),'

      
      ',paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
        if(ctspec$indvarying[rowi]) paste0('output_hsd_',ctspec$param[rowi],' = ',
          'exp(hypersd[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),']); \n',
          if(!is.na(ctspec$transform[rowi])) paste0(
            'output_hsd_',ctspec$param[rowi],' = fabs
            ((', 
            gsub('param', paste0('(hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] + output_hsd_',
              ctspec$param[rowi],')'),ctspec$transform[rowi]), ') - (',
            gsub('param', paste0('(hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] - output_hsd_',
              ctspec$param[rowi],')'),ctspec$transform[rowi]),'))/2; \n')
            )
      })),collapse=''),'

      
      ',if(n.TIpred > 0) paste0(unlist(lapply(1:n.TIpred,function(tip){
        paste0(unlist(lapply(1:nrow(ctspec),function(rowi){
          if(ctspec$indvarying[rowi] & ctspec[,paste0(TIpredNames[tip],'_effect')][rowi]) paste0('
            output_tip_',TIpredNames[tip], '_on_', ctspec$param[rowi],' = ',
            'tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']; \n',
            if(!is.na(ctspec$transform[rowi])) paste0('output_tip_', TIpredNames[tip], '_on_', ctspec$param[rowi],' = ((', 
              gsub('param', 
                paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] + tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']'),
                ctspec$transform[rowi]), 
              ') - (',
              gsub('param', 
                paste0('hypermeans[',which(ctspec$param[is.na(ctspec$value)] == ctspec$param[rowi]),'] - tipredeffect[',which(ctspec$param[ctspec$indvarying] == ctspec$param[rowi]),',',tip,']'),
                ctspec$transform[rowi]),'))/2; \n')
          )
        })),collapse='')
        })),collapse=''),'
    
        }')
    }
    
    if(is.na(stanmodelobj)) stanmodelobj<-writemodel(init=initwithoptim,optimize=initwithoptim || optimize)
      
  
  out<-stanmodelobj
  
  if(fit==TRUE){
    
    standata<-list(
      Y=cbind(datalong[,manifestNames]),
      subject=datalong[,'id'],
      nsubjects=nsubjects,
      nmanifest=n.manifest,
      T0check=T0check,
      indvaryingindex=array(which(ctspec$indvarying[is.na(ctspec$value)]),dim=c(nindvarying)),
      continuoustime=sum(continuoustime),
      nlatent=n.latent,
      ntipred=n.TIpred,
      ntdpred=n.TDpred,
      nparams=nparams,
      stationarymeanprior=array(ctstanmodelobj$stationarymeanprior,dim=n.latent),
      stationaryvarprior=array(ctstanmodelobj$stationaryvarprior,dim=n.latent),
      nindvarying=nindvarying,
      sdscale=array(ctspec$sdscale[ctspec$indvarying]),
      IIparams = diag(nparams),
      ndatapoints=nrow(datalong),
      padeC=rbind(c(120, 60, 12, 1, 0, 0, 0, 0, 0, 0), c(30240, 
        15120, 3360, 420, 30, 1, 0, 0, 0, 0), c(17297280, 
          8648640, 1995840, 277200, 25200, 1512, 56, 1, 0, 
          0), c(17643225600, 8821612800, 2075673600, 302702400, 
            30270240, 2162160, 110880, 3960, 90, 1)),
      padeCbig= c(64764752532480000, 32382376266240000, 7771770303897600, 
        1187353796428800, 129060195264000, 10559470521600, 
        670442572800, 33522128640, 1323241920, 40840800, 
        960960, 16380, 182, 1),
      dT=dT,
      driftindex=driftindex,
      cintindex=cintindex,
      diffusionindex=diffusionindex,
      nobs_y=array(apply(datalong[,manifestNames,drop=FALSE],1,function(x) length(x[x!=99999])),dim=nrow(datalong)),
      whichobs_y=matrix(t(apply(datalong[,manifestNames,drop=FALSE],1,function(x) {
        out<-as.numeric(which(x!=99999))
        if(length(out)==0) out<-rep(0,n.manifest)
        if(length(out)<n.manifest) out<-c(out,rep(0,n.manifest-length(out)))
        out
      }) ),nrow=c(nrow(datalong),ncol=n.manifest)))
    
    if(n.TIpred > 0) standata$tipreds <- tipreds
    
    if(n.TDpred > 0) standata<-c(standata,list(tdpreds=array(tdpreds,dim=c(nrow(tdpreds),ncol(tdpreds)))))
    
    
    control<-list(adapt_delta=adapt_delta,
      adapt_term_buffer=min(c(iter/10,max(iter-20,75))),
      adapt_init_buffer=4,
      adapt_window=2,
      # adapt_kappa=.6,
      # adapt_gamma=.1,
      # metric="unit_e",
      max_treedepth=max_treedepth,stepsize=.001)
    
    stanseed<-floor(as.numeric(Sys.time()))

    if(!exists('sample_file')){
      if(plot==TRUE) sample_file<-paste0(tmpdir,'\\\\',stanseed,'samples.csv')
      if(plot==FALSE) sample_file<-NULL
    }
    
    if(initwithoptim & chains > 0){#optimize with bfgs for initial values
      
      sm <- stan(model_code = c(stanmodelobj), 
        data = standata, chains = 0)
      
      npars=get_num_upars(sm)
      
      if(any(ctspec$indvarying)) hypersdindex=((npars+1 -  sum(ctspec$indvarying)):npars)-
        length(constrain_pars(sm,rep(0,npars))$tipredeffect) else hypersdindex<-NULL

      lp<-function(parm) {
        # parm[hypersdindex]<-2
        out<-try(log_prob(sm,upars=parm))
        if(class(out)=='try-error') {
          out=-9999999999999999
          # print(constrain_pars(sm,parm))
        }
        # out=out +sum(dnorm(parm,0,10,log=TRUE))
        return(out)
      }
      
      grf<-function(parm) {
        # parm[hypersdindex]<-0
        grad_log_prob(sm,upars=parm)
      }
    
    optimfit <- optim(rnorm(npars,0,.001), lp, gr=grf, 
      control = list(fnscale = -1,trace=1,parscale=rep(.00001,npars),maxit=2000,factr=1e-14,reltol=1e-12,lmm=100), 
      method='L-BFGS-B',hessian = FALSE)
    # browser()
    parsout=optimfit$par
    # parsout[hypersdindex]=0
    
    inits=rstan::constrain_pars(sm,parsout)
    stanmodelobj<-writemodel(init=FALSE,optimize=FALSE)
  }

  if(!is.null(inits)){
    staninits=list(inits)
    if(chains > 1){
      for(i in 2:chains){
        staninits[[i]]<-inits
      }
    }
  }
    
  
    if(is.null(inits)){
      staninits=list()
      for(i in 1:(chains+1)){
        staninits[[i]]=list(hypersdbase=array(rnorm(nindvarying,1,.5),dim=c(nindvarying)))
      }
    }
    
    if(plot==TRUE) {
      stanplot(chains=chains,seed=stanseed)
    }
  
  out <- stan(model_code = c(stanmodelobj), 
    enable_random_init=TRUE,init_r=.1,
    init=staninits,
    refresh=20,
    iter=iter,
    data = standata, chains = ifelse(optimize==FALSE & vb==FALSE,chains,0), control=control,
    sample_file=sample_file,
    cores=max(c(chains,detectCores())),...) 
  
  
  
  if(optimize==FALSE & vb==FALSE){ #summarise
    if(plot==TRUE) {
      for(chaini in 1:chains) system(paste0("rm ",stanseed,"samples.csv",chaini))
      system(paste0('rm stanplottemp.R'))
    }
  }
  
  if(optimize==TRUE && fit==TRUE) {
    
    out <- optimizing(object = out@stanmodel, 
      # init=0,
      # algorithm='BFGS',
      as_vector=F,
      history_size=20,
      init_alpha=1e-4,
      tol_obj=1e-12, tol_grad=1e-12,tol_param=1e-12,tol_rel_grad=0, tol_rel_obj=0,
      data = standata, iter=120000)
    
    
  }
  
  if(vb==TRUE && fit==TRUE) {
    out <- vb(object = out@stanmodel, 
      iter=iter,
      data = standata,...)
    
  }
  
        } # end if fit==TRUE



return(out)
        }
